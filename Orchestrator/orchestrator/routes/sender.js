var express = require("express");
var router = express.Router();
const bodyParser = require("body-parser");
router.use(bodyParser.json());
var amqp = require("amqplib/callback_api");
var Docker = require("dockerode");
const Counts = require("../models/count");
var docker = new Docker();
router.route("/read").post((req, res, next) => {
  connectToServer("readQ", req.body, (responseMsg) => {
    /* Maintaing a counter variable in orchestrator db and incrementing by 1 on every subsequent read request */
    Counts.find({ id: 1 }).then((count) => {
      if (count.length == 0) {
        Counts.create({ id: 1, counter: 1 }).then((c) => {
          console.log("Counter created!!");
        });
      } else {
        Counts.findByIdAndUpdate(
          { id: 1 },
          { $inc: { counter: 1 } },
          { new: true },
          (err, Res) => {
            if (err) console.log(err);
          }
        );
      }
    });

    console.log("Message from readQ  ");
    console.log(responseMsg);
    res.statusCode = parseInt(responseMsg.statusCode);
    res.send(responseMsg.send);
  });
});

router.route("/write").post((req, res, next) => {
  connectToServer("writeQ", req.body, (msg) => {
    console.log(msg);
  });
  res.statusCode = 201;
  res.send();
});

var connectToServer = (requestFor, requestMsg, callback) => {
  amqp.connect("amqp://localhost", function (error0, connection) {
    if (error0) {
      throw error0;
    }
    connection.createChannel(function (error1, channel) {
      if (error1) {
        throw error1;
      }
      //var msg = args.slice(1).join(' ') || 'Hello World!';
      var exchange = "orchestrate";
      channel.assertExchange(exchange, "direct", {
        durable: false,
      });
      channel.prefetch(1);
      /*If a worker is busy it will send the message to some other worker. 1message/worker at a time*/

      if (requestFor == "readQ") {
        /*Creating responseQ */
        channel.assertQueue("responseQ");

        /*Bind of responseQ */
        channel.bindQueue("responseQ", exchange, "responseQ");
        var correlationId = generateUuid(); /*Generating a correlation id which will be unique for each request */

        /* RPC implementation with slave worker where request queue is readQ and callback queue is responseQ */

        /*Publishing the incoming request to readQ with callback queue as responseQ */
        channel.publish(
          exchange,
          "readQ",
          Buffer.from(JSON.stringify(requestMsg)),
          { correlationId: correlationId, replyTo: "responseQ" }
        );
        /*Consume the response generated by the slave worker from responseQ */
        channel.consume(
          "responseQ",
          function (msg) {
            console.log("RESPONSEQ response " + msg.content.toString());
            msg1 = msg.content;
            if (msg.properties.correlationId == correlationId) {
              connection.close();
              return callback(JSON.parse(msg1));
              //console.log(' [.] Got %s', msg.content.toString());
            }
          },
          {
            noAck: true,
          }
        );
      } else if (requestFor == "writeQ") {
        /* If args[0] is writeQ no need to make responseQ */
        /* Publishing all write requests to writeQ */
        channel.publish(
          exchange,
          "writeQ",
          Buffer.from(JSON.stringify(requestMsg))
        );

        //connection.close();
        return callback("DONE!");
      } else {
        /* If no request has been made to readQ or writeQ then exit */
        connection.close();
        process.exit(0);
      }
    });
  });

  var generateUuid = () => {
    return (
      Math.random().toString() +
      Math.random().toString() +
      Math.random().toString()
    );
  };
};

module.exports = router;
