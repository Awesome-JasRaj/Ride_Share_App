var express = require('express');
var router = express.Router();
const bodyParser = require("body-parser");
router.use(bodyParser.json());
var amqp = require('amqplib/callback_api');

router.route("/read")
    .post((req, res, next) => {
        connectToServer('readQ', req.body, (responseMsg) => {
            console.log("Message from readQ  ");
            console.log(responseMsg);
            res.statusCode = parseInt(responseMsg.statusCode);
            res.send(responseMsg.send);
        });
    });

router.route("/write")
    .post((req, res, next) => {
        connectToServer('writeQ', req.body, (msg) => {
            console.log(msg);
        });
        res.statusCode = 201;
        res.send();
    });

var connectToServer = (requestFor, requestMsg, callback) => {
    amqp.connect('amqp://localhost', function (error0, connection) {
        if (error0) {
            throw error0;
        }
        connection.createChannel(function (error1, channel) {
            if (error1) {
                throw error1;
            }
            //var msg = args.slice(1).join(' ') || 'Hello World!';
            var exchange = 'orchestrate';
            channel.assertExchange(exchange, 'direct', {
                durable: false
            });
            channel.prefetch(1); /*If a worker is busy it will send the message to some other worker. 1message/worker at a time*/

            if (requestFor == 'readQ') {
                /*Creating responseQ */
                channel.assertQueue('responseQ');

                /*Bind of responseQ */
                channel.bindQueue('responseQ', exchange, 'responseQ');
                var correlationId = generateUuid(); /*Generating a correlation id which will be unique for each request */

                /* RPC implementation with slave worker where request queue is readQ and callback queue is responseQ */

                /*Publishing the incoming request to readQ with callback queue as responseQ */
                channel.publish(exchange, 'readQ', Buffer.from(JSON.stringify(requestMsg)), { correlationId: correlationId, replyTo: 'responseQ' });
                /*Consume the response generated by the slave worker from responseQ */
                channel.consume('responseQ', function (msg) {
                    console.log("RESPONSEQ response " + msg.content.toString());
                    if (msg.properties.correlationId == correlationId) {
                        connection.close();
                        return callback(JSON.parse(msg.content));
                        //console.log(' [.] Got %s', msg.content.toString());
                    }
                }, {
                    noAck: true
                });
            }
            else if (requestFor == 'writeQ') {      /* If args[0] is writeQ no need to make responseQ */
                /* Publishing all write requests to writeQ */
                channel.publish(exchange, 'writeQ', Buffer.from(JSON.stringify(requestMsg)));
                connection.close();
                return callback("DONE!");
            }
            else {                                  /* If no request has been made to readQ or writeQ then exit */
                connection.close();
                process.exit(0);
            }
        });
    });

    var generateUuid = () => {
        return Math.random().toString() +
            Math.random().toString() +
            Math.random().toString();
    }
}




module.exports = router;